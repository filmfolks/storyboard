<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Mobile-Optimized Gutendex Ebook & LibriVox Player</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #fff;
    color: #000;
  }
  .dark-mode {
    background-color: #121212;
    color: #e0e0e0;
  }
  header {
    background-color: #0066cc;
    color: white;
    padding: 10px 15px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 10px;
  }
  header select, header button {
    padding: 8px 12px;
    font-size: 14px;
    border-radius: 4px;
    border: none;
    cursor: pointer;
  }
  header select {
    min-width: 160px;
  }
  #results {
    padding: 15px;
  }
  #results ul {
    list-style: none;
    padding: 0;
  }
  #results li {
    margin-bottom: 10px;
    cursor: pointer;
    border-bottom: 1px solid #ddd;
    padding-bottom: 5px;
  }
  #reader {
    padding: 15px;
  }
  .hidden {
    display: none;
  }
  #book-title {
    font-weight: bold;
    font-size: 20px;
    margin-bottom: 10px;
  }
  #book-content {
    white-space: pre-wrap;
    font-size: 16px;
    line-height: 1.6;
    height: 70vh; /* More screen space for book */
    overflow-y: auto;
    margin-bottom: 10px;
  }
  #controls {
    margin-top: 10px;
    display: flex;
    flex-wrap: nowrap; /* Keep buttons in one line */
    align-items: center;
    gap: 10px;
    overflow-x: auto; /* Allow horizontal scrolling on mobile */
    padding-bottom: 10px;
  }
  #controls button, #controls select, #controls input[type='range'] {
    padding: 8px 12px;
    font-size: 14px;
    border-radius: 4px;
    border: 1px solid #ccc;
    cursor: pointer;
    white-space: nowrap;
  }
  #controls input[type='range'] {
    flex-grow: 1;
    min-width: 80px;
  }
  #audioPlayer {
    width: 100%;
    margin-top: 10px;
    outline: none;
  }
  @media (max-width: 768px) {
    header {
      flex-direction: column;
      align-items: stretch;
    }
    header select {
      width: 100%;
      margin-bottom: 8px;
    }
  }
</style>
</head>
<body>
<header>
  <select id="genreSelect">
    <option value="">Select Genre</option>
  </select>
  <select id="authorSelect">
    <option value="">Select Author</option>
  </select>
  <select id="categorySelect">
    <option value="">Select Category</option>
  </select>
  <button id="filterButton">Filter Books</button>
  <button id="darkModeButton">Dark Mode</button>
  <button id="fullscreenButton">Fullscreen</button>
</header>
<div id="results"></div>
<div id="reader" class="hidden">
  <div id="book-title"></div>
  <div id="error-message" class="hidden" style="color:red;font-weight:bold"></div>
  <div id="book-content"></div>
  <div id="controls">
    <button id="fontIncrease">A+</button>
    <button id="fontDecrease">A-</button>
    <button id="ttsPlayPause">Play TTS</button>
    <button id="ttsStop">Stop TTS</button>
    <label for="voiceSelect" class="desktop-only">Voice:</label>
    <select id="voiceSelect" aria-label="Select voice for text to speech" class="desktop-only"></select>
    <label for="rateRange" class="desktop-only">Rate:</label>
    <input type="range" id="rateRange" min="0.5" max="2" value="1" step="0.1" aria-label="Speech rate control" class="desktop-only"/>
    <label for="pitchRange" class="desktop-only">Pitch:</label>
    <input type="range" id="pitchRange" min="0" max="2" value="1" step="0.1" aria-label="Speech pitch control" class="desktop-only"/>
    <button id="playAudiobook">Play Audiobook</button>
    <button id="backButton">Back to List</button>
  </div>
  <audio id="audioPlayer" controls class="hidden" aria-label="Audiobook player"></audio>
</div>
<script>
  const genreSelect = document.getElementById('genreSelect');
  const authorSelect = document.getElementById('authorSelect');
  const categorySelect = document.getElementById('categorySelect');
  const filterButton = document.getElementById('filterButton');
  const resultsDiv = document.getElementById('results');
  const readerDiv = document.getElementById('reader');
  const bookTitleDiv = document.getElementById('book-title');
  const bookContentDiv = document.getElementById('book-content');
  const errorMessageDiv = document.getElementById('error-message');
  const fontIncreaseBtn = document.getElementById('fontIncrease');
  const fontDecreaseBtn = document.getElementById('fontDecrease');
  const ttsPlayPauseBtn = document.getElementById('ttsPlayPause');
  const ttsStopBtn = document.getElementById('ttsStop');
  const voiceSelect = document.getElementById('voiceSelect');
  const rateRange = document.getElementById('rateRange');
  const pitchRange = document.getElementById('pitchRange');
  const darkModeButton = document.getElementById('darkModeButton');
  const fullscreenButton = document.getElementById('fullscreenButton');
  const backButton = document.getElementById('backButton');
  const playAudiobookBtn = document.getElementById('playAudiobook');
  const audioPlayer = document.getElementById('audioPlayer');

  let currentFontSize = 16;
  let speechSynthesisUtterance = null;
  let isDarkMode = false;
  let voices = [];
  let currentBookTitle = '';
  let currentBookAuthor = '';

  function populateSelect(select, options) {
    options.forEach(opt => {
      const optionEl = document.createElement('option');
      optionEl.value = opt.toLowerCase();
      optionEl.textContent = opt;
      select.appendChild(optionEl);
    });
  }

  const genres = ['Science Fiction', 'Romance', 'Fantasy', 'Adventure', 'Horror', 'Children', 'Mystery', 'Historical'];
  const categories = ['Children', 'Classics', 'Fiction', 'Nonfiction', 'Poetry', 'Drama', 'Horror', 'Science Fiction'];

  populateSelect(genreSelect, genres);
  populateSelect(categorySelect, categories);

  function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  }

  if (isMobile()) {
      document.querySelectorAll('.desktop-only').forEach(el => el.style.display = 'none');
  }

  async function fetchAuthors() {
    try {
      const response = await fetch('https://gutendex.com/books?sort=popular');
      const data = await response.json();
      const authorsSet = new Set();
      data.results.forEach(book => {
        book.authors.forEach(author => {
          authorsSet.add(author.name);
        });
      });
      const authors = Array.from(authorsSet).sort();
      authors.forEach(author => {
        const optionEl = document.createElement('option');
        optionEl.value = author.toLowerCase();
        optionEl.textContent = author;
        authorSelect.appendChild(optionEl);
      });
    } catch (error) {
      console.error('Error fetching authors', error);
    }
  }
  fetchAuthors();

  async function filterBooks() {
    resultsDiv.innerHTML = '<p>Loading books...</p>';
    readerDiv.classList.add('hidden');
    stopAudio();
    stopTTS();
    try {
      const selectedGenre = genreSelect.value;
      const selectedAuthor = authorSelect.value;
      const selectedCategory = categorySelect.value;

      let combinedResults = [];
      const seenIds = new Set();

      async function addResults(url) {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`API error: ${res.status}`);
        const data = await res.json();
        data.results.forEach(book => {
          if (!seenIds.has(book.id)) {
            combinedResults.push(book);
            seenIds.add(book.id);
          }
        });
      }

      let queries = [];
      if (selectedGenre) {
        queries.push(`https://gutendex.com/books?topic=${selectedGenre}&sort=popular`);
      }
      if (selectedCategory && selectedCategory !== selectedGenre) {
        queries.push(`https://gutendex.com/books?topic=${selectedCategory}&sort=popular`);
      }
      if (selectedAuthor) {
        queries.push(`https://gutendex.com/books?search=${selectedAuthor}&sort=popular`);
      }
      if (queries.length === 0) {
        queries.push('https://gutendex.com/books?sort=popular');
      }

      await Promise.all(queries.map(q => addResults(q)));

      if (combinedResults.length === 0) {
        resultsDiv.innerHTML = '<p>No books found.</p>';
        return;
      }

      displayResults(combinedResults);
    } catch (error) {
      console.error('Filter error:', error);
      resultsDiv.innerHTML = '<p>Error retrieving books. Check console for details.</p>';
    }
  }

  function displayResults(books) {
    let html = '<ul>';
    books.forEach(book => {
      html += `<li data-id="${book.id}">${book.title} <br/><small>by ${book.authors.map(a => a.name).join(", ")}</small></li>`;
    });
    html += '</ul>';
    resultsDiv.innerHTML = html;

    document.querySelectorAll('#results li').forEach(li => {
      li.addEventListener('click', async () => {
        const bookId = li.getAttribute('data-id');
        await openBook(bookId);
      });
    });
  }

  async function openBook(bookId) {
    resultsDiv.innerHTML = '<p>Loading book content...</p>';
    errorMessageDiv.classList.add('hidden');
    bookContentDiv.textContent = '';
    stopAudio();
    stopTTS();
    try {
      const response = await fetch(`https://gutendex.com/books/${bookId}`);
      if (!response.ok) throw new Error(`Metadata fetch failed: ${response.status}`);
      const book = await response.json();
      bookTitleDiv.textContent = book.title + ' by ' + book.authors.map(a => a.name).join(', ');
      currentBookTitle = book.title;
      currentBookAuthor = book.authors[0] ? book.authors[0].name.split(',')[0] : '';


      const possibleFormats = [
        'text/plain; charset=utf-8',
        'text/plain',
        'text/html; charset=utf-8',
        'text/html',
      ];

      let textData = '';
      for (const fmt of possibleFormats) {
        let textUrl = book.formats[fmt];
        if (textUrl) {
          const proxyUrl = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(textUrl);
          const textResponse = await fetch(proxyUrl);
          if (textResponse.ok) {
            textData = await textResponse.text();
            if (fmt.includes('html')) {
              const parser = new DOMParser();
              const doc = parser.parseFromString(textData, 'text/html');
              textData = doc.body.textContent || '';
            }
            if (textData) break;
          }
        }
      }

      if (!textData) {
        throw new Error('No supported readable format found.');
      }

      bookContentDiv.textContent = textData.trim();
      currentFontSize = 16;
      bookContentDiv.style.fontSize = currentFontSize + 'px';
      readerDiv.classList.remove('hidden');
      resultsDiv.innerHTML = '';
    } catch (err) {
      console.error('Load error:', err);
      errorMessageDiv.textContent = `Error: ${err.message}`;
      errorMessageDiv.classList.remove('hidden');
      resultsDiv.innerHTML = '';
    }
  }

  function stopTTS() {
    if (speechSynthesis.speaking) {
      speechSynthesis.cancel();
      ttsPlayPauseBtn.textContent = 'Play TTS';
    }
  }

  function stopAudio() {
    audioPlayer.pause();
    audioPlayer.currentTime = 0;
    audioPlayer.classList.add('hidden');
  }

  ttsPlayPauseBtn.addEventListener('click', () => {
    stopAudio();
    if (speechSynthesis.speaking) {
      speechSynthesis.pause();
      ttsPlayPauseBtn.textContent = 'Resume TTS';
    } else {
        if (speechSynthesis.paused) {
            speechSynthesis.resume();
            ttsPlayPauseBtn.textContent = 'Pause TTS';
            return;
        }
      const text = bookContentDiv.textContent;
      if (text.length > 0) {
        speechSynthesisUtterance = new SpeechSynthesisUtterance(text);
        if (!isMobile()) {
            speechSynthesisUtterance.voice = voices.find(v => v.name === voiceSelect.value);
            speechSynthesisUtterance.rate = parseFloat(rateRange.value);
            speechSynthesisUtterance.pitch = parseFloat(pitchRange.value);
        }
        speechSynthesisUtterance.onend = () => {
          ttsPlayPauseBtn.textContent = 'Play TTS';
        };
        speechSynthesis.speak(speechSynthesisUtterance);
        ttsPlayPauseBtn.textContent = 'Pause TTS';
      }
    }
  });

  ttsStopBtn.addEventListener('click', () => {
    stopTTS();
  });

  function loadVoices() {
    voices = speechSynthesis.getVoices();
    voiceSelect.innerHTML = '';
    voices.forEach(voice => {
      const option = document.createElement('option');
      option.textContent = `${voice.name} (${voice.lang})`;
      option.setAttribute('data-lang', voice.lang);
      option.setAttribute('data-name', voice.name);
      voiceSelect.appendChild(option);
    });
  }
  
  if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = loadVoices;
  }
  loadVoices();

  fontIncreaseBtn.addEventListener('click', () => {
    currentFontSize += 2;
    bookContentDiv.style.fontSize = currentFontSize + 'px';
  });

  fontDecreaseBtn.addEventListener('click', () => {
    if (currentFontSize > 12) {
      currentFontSize -= 2;
      bookContentDiv.style.fontSize = currentFontSize + 'px';
    }
  });

  darkModeButton.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    darkModeButton.textContent = document.body.classList.contains('dark-mode') ? 'Light Mode' : 'Dark Mode';
  });

  fullscreenButton.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  });

  backButton.addEventListener('click', () => {
    stopTTS();
    stopAudio();
    readerDiv.classList.add('hidden');
    resultsDiv.innerHTML = '';
    errorMessageDiv.classList.add('hidden');
  });

  playAudiobookBtn.addEventListener('click', async () => {
    stopTTS();
    audioPlayer.classList.add('hidden');
    alert('Searching for audiobook...');
    try {
      const lvUrl = `https://librivox.org/api/feed/audiobooks/?title=${encodeURIComponent(currentBookTitle)}&author=${encodeURIComponent(currentBookAuthor)}&format=json&extended=1`;
      const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(lvUrl)}`;
      const response = await fetch(proxyUrl);
      if (!response.ok) throw new Error(`LibriVox API error`);
      const data = await response.json();
      
      if (data.books && data.books.length > 0 && data.books[0].url_zip_file) {
        // Find the first mp3 track
        const track = data.books[0].sections.find(s => s.file_name.endsWith('.mp3'));
        if (track) {
            audioPlayer.src = track.play_url;
            audioPlayer.classList.remove('hidden');
            audioPlayer.play();
        } else {
             alert('No MP3 track found for this audiobook.');
        }
      } else {
        alert('No matching audiobook found on LibriVox.');
      }
    } catch (err) {
      console.error('LibriVox error:', err);
      alert('Error fetching audiobook.');
    }
  });

  filterButton.addEventListener('click', filterBooks);
</script>
</body>
</html>
